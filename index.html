<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø¨Ø§Ø²ÛŒ Ø³Ù‡ Ø³Ù†Ú¯ | Three Men's Morris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5deb3 0%, #d2b48c 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 1000px;
        }
        
        h1 {
            color: #8b4513;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            color: #654321;
            font-size: 1.2rem;
            margin-bottom: 15px;
        }
        
        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
            max-width: 1200px;
        }
        
        .board-section {
            flex: 1;
            min-width: 600px;
        }
        
        .info-section {
            flex: 1;
            min-width: 350px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        canvas {
            display: block;
            background-color: #f5deb3;
            border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
        
        .game-info {
            margin-bottom: 25px;
        }
        
        .game-state {
            background-color: #f8f0e3;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-right: 5px solid #8b4513;
        }
        
        .player-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .player-box {
            padding: 15px;
            border-radius: 10px;
            width: 48%;
            text-align: center;
            transition: all 0.3s;
        }
        
        .player1 {
            background-color: rgba(220, 20, 60, 0.1);
            border: 3px solid #dc143c;
        }
        
        .player2 {
            background-color: rgba(30, 144, 255, 0.1);
            border: 3px solid #1e90ff;
        }
        
        .current-turn {
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            transform: scale(1.05);
        }
        
        .player-name {
            font-size: 1.4rem;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .player1 .player-name {
            color: #dc143c;
        }
        
        .player2 .player-name {
            color: #1e90ff;
        }
        
        .player-pieces {
            font-size: 1.2rem;
            margin-bottom: 5px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 25px;
        }
        
        button {
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .restart-btn {
            background-color: #8b4513;
            color: white;
        }
        
        .restart-btn:hover {
            background-color: #654321;
            transform: translateY(-3px);
        }
        
        .rules-btn {
            background-color: #2e8b57;
            color: white;
        }
        
        .rules-btn:hover {
            background-color: #1f6b42;
            transform: translateY(-3px);
        }
        
        .rules {
            margin-top: 25px;
            background-color: #f8f8f8;
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #2e8b57;
            display: none;
        }
        
        .rules.active {
            display: block;
        }
        
        .rules h3 {
            color: #2e8b57;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }
        
        .rules ul {
            padding-right: 20px;
            margin-bottom: 15px;
        }
        
        .rules li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        .phase-indicator {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .phase {
            padding: 8px 15px;
            border-radius: 20px;
            background-color: #e0e0e0;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .phase.active {
            background-color: #8b4513;
            color: white;
        }
        
        @media (max-width: 1000px) {
            .game-container {
                flex-direction: column;
            }
            
            .board-section, .info-section {
                min-width: 100%;
            }
        }
        
        .message {
            font-size: 1.3rem;
            font-weight: bold;
            text-align: center;
            padding: 15px;
            background-color: rgba(255, 255, 200, 0.9);
            border-radius: 10px;
            margin-bottom: 20px;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px dashed #8b4513;
        }
        
        .mill-message {
            background-color: rgba(144, 238, 144, 0.9);
            border-color: #228b22;
        }
        
        .game-over {
            background-color: rgba(255, 215, 0, 0.9);
            border-color: #ff8c00;
        }
        
        .winning-message {
            background-color: rgba(50, 205, 50, 0.9);
            border-color: #228b22;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Ø¨Ø§Ø²ÛŒ Ø³Ù‡ Ø³Ù†Ú¯ | Three Men's Morris</h1>
        <p class="subtitle">Ù†Ø³Ø®Ù‡ Ø³Ø§Ø¯Ù‡ Ø´Ø¯Ù‡: ÙÙ‚Ø· Ø¨Ø±Ù†Ø¯Ù‡ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯! Ø§ÙˆÙ„ÛŒÙ† Ú©Ø³ÛŒ Ú©Ù‡ Ø³Ù‡ Ù…Ù‡Ø±Ù‡ Ø¯Ø± ÛŒÚ© Ø®Ø· Ù‚Ø±Ø§Ø± Ø¯Ù‡Ø¯ Ø¨Ø±Ù†Ø¯Ù‡ Ø§Ø³Øª.</p>
    </div>
    
    <div class="game-container">
        <div class="board-section">
            <canvas id="gameCanvas" width="600" height="600"></canvas>
        </div>
        
        <div class="info-section">
            <div class="game-info">
                <div class="message" id="gameMessage">
                    Ø¨Ø§Ø²ÛŒ Ø´Ø±ÙˆØ¹ Ø´Ø¯! Ù†ÙˆØ¨Øª Ø¨Ø§Ø²ÛŒÚ©Ù† Ù‚Ø±Ù…Ø² (Ù‚Ø±Ø§Ø± Ø¯Ø§Ø¯Ù† Ø³Ù†Ú¯â€ŒÙ‡Ø§)
                </div>
                
                <div class="player-info">
                    <div class="player-box player1 current-turn" id="player1Box">
                        <div class="player-name">Ø¨Ø§Ø²ÛŒÚ©Ù† Ù‚Ø±Ù…Ø²</div>
                        <div class="player-pieces">Ø³Ù†Ú¯â€ŒÙ‡Ø§ÛŒ Ø±ÙˆÛŒ ØµÙØ­Ù‡: <span id="player1Pieces">0</span></div>
                        <div class="player-pieces">Ø³Ù†Ú¯â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ù‚ÛŒÙ…Ø§Ù†Ø¯Ù‡: <span id="player1Remaining">3</span></div>
                    </div>
                    
                    <div class="player-box player2" id="player2Box">
                        <div class="player-name">Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¢Ø¨ÛŒ</div>
                        <div class="player-pieces">Ø³Ù†Ú¯â€ŒÙ‡Ø§ÛŒ Ø±ÙˆÛŒ ØµÙØ­Ù‡: <span id="player2Pieces">0</span></div>
                        <div class="player-pieces">Ø³Ù†Ú¯â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ù‚ÛŒÙ…Ø§Ù†Ø¯Ù‡: <span id="player2Remaining">3</span></div>
                    </div>
                </div>
                
                <div class="phase-indicator">
                    <div class="phase active" id="phase1">ÙØ§Ø² Û±: Ù‚Ø±Ø§Ø± Ø¯Ø§Ø¯Ù†</div>
                    <div class="phase" id="phase2">ÙØ§Ø² Û²: Ø­Ø±Ú©Øª</div>
                </div>
            </div>
            
            <div class="controls">
                <button class="restart-btn" onclick="restartGame()">Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯</button>
                <button class="rules-btn" onclick="toggleRules()">Ù†Ù…Ø§ÛŒØ´/Ù¾Ù†Ù‡Ø§Ù† Ú©Ø±Ø¯Ù† Ù‚ÙˆØ§Ù†ÛŒÙ†</button>
            </div>
            
            <div class="rules" id="rulesPanel">
                <h3>Ù‚ÙˆØ§Ù†ÛŒÙ† Ø¬Ø¯ÛŒØ¯ Ø¨Ø§Ø²ÛŒ Ø³Ù‡ Ø³Ù†Ú¯</h3>
                <ul>
                    <li><strong>Ù‡Ø¯Ù Ø¨Ø§Ø²ÛŒ:</strong> Ø§ÙˆÙ„ÛŒÙ† Ø¨Ø§Ø²ÛŒÚ©Ù†ÛŒ Ú©Ù‡ Ø³Ù‡ Ø³Ù†Ú¯ Ø®ÙˆØ¯ Ø±Ø§ Ø¯Ø± ÛŒÚ© Ø®Ø· (Ø±Ø§Ø³ØªØŒ Ú†Ù¾ ÛŒØ§ Ù…ÙˆØ±Ø¨) Ù‚Ø±Ø§Ø± Ø¯Ù‡Ø¯ Ø¨Ø±Ù†Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.</li>
                    <li><strong>ÙØ§Ø² Û± - Ù‚Ø±Ø§Ø± Ø¯Ø§Ø¯Ù† Ø³Ù†Ú¯â€ŒÙ‡Ø§:</strong> Ù‡Ø± Ø¨Ø§Ø²ÛŒÚ©Ù† Û³ Ø³Ù†Ú¯ Ø¯Ø§Ø±Ø¯ Ú©Ù‡ Ø¨Ù‡ Ù†ÙˆØ¨Øª Ø±ÙˆÛŒ Ù†Ù‚Ø§Ø· ØµÙØ­Ù‡ Ù‚Ø±Ø§Ø± Ù…ÛŒâ€ŒØ¯Ù‡Ø¯.</li>
                    <li><strong>ÙØ§Ø² Û² - Ø­Ø±Ú©Øª Ø³Ù†Ú¯â€ŒÙ‡Ø§:</strong> Ù¾Ø³ Ø§Ø² Ù‚Ø±Ø§Ø± Ø¯Ø§Ø¯Ù† Ù‡Ù…Ù‡ Ø³Ù†Ú¯â€ŒÙ‡Ø§ØŒ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ Ø³Ù†Ú¯â€ŒÙ‡Ø§ÛŒ Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ù‡ Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø¬Ø§ÙˆØ± Ø®Ø§Ù„ÛŒ Ø­Ø±Ú©Øª Ø¯Ù‡Ù†Ø¯.</li>
                    <li><strong>Ù¾Ø§ÛŒØ§Ù† Ø¨Ø§Ø²ÛŒ:</strong> Ø¨Ø§Ø²ÛŒ ÙÙ‚Ø· Ø²Ù…Ø§Ù†ÛŒ Ù¾Ø§ÛŒØ§Ù† Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯ Ú©Ù‡ ÛŒÚ© Ø¨Ø§Ø²ÛŒÚ©Ù† Ø³Ù‡ Ø³Ù†Ú¯ Ø®ÙˆØ¯ Ø±Ø§ Ø¯Ø± ÛŒÚ© Ø®Ø· Ù‚Ø±Ø§Ø± Ø¯Ù‡Ø¯. Ù‡ÛŒÚ† Ø¨Ø§Ø®ØªÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯!</li>
                    <li><strong>ØªØ´Ú©ÛŒÙ„ Ø®Ø· Ø¨Ø±Ù†Ø¯Ù‡:</strong> Ø®Ø· Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø§ÙÙ‚ÛŒØŒ Ø¹Ù…ÙˆØ¯ÛŒ ÛŒØ§ Ù…ÙˆØ±Ø¨ Ø¨Ø§Ø´Ø¯ (Ø¯Ø± Ù…Ø¬Ù…ÙˆØ¹ Û±Û¶ Ø­Ø§Ù„Øª Ù…Ø®ØªÙ„Ù Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯Ù†).</li>
                </ul>
                <p><strong>Ù†Ú©ØªÙ‡:</strong> Ù‡ÛŒÚ† Ù‚Ø§Ù†ÙˆÙ† Ø­Ø°Ù Ù…Ù‡Ø±Ù‡ Ø­Ø±ÛŒÙØŒ Ù‚Ø§Ù†ÙˆÙ† Ù¾Ø±ÙˆØ§Ø² ÛŒØ§ Ø´Ø±Ø§ÛŒØ· Ø¨Ø§Ø®Øª ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯. Ø¨Ø§Ø²ÛŒ ØªØ§ Ø²Ù…Ø§Ù†ÛŒ Ø§Ø¯Ø§Ù…Ù‡ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯ Ú©Ù‡ Ú©Ø³ÛŒ Ø¨Ø±Ù†Ø¯Ù‡ Ø´ÙˆØ¯!</p>
            </div>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const boardSize = 500;
        const boardOffset = (canvas.width - boardSize) / 2;
        const pointRadius = 20;
        const PIECES_PER_PLAYER = 3;
        
        // Board positions (24 points)
        const boardPositions = [
            // Outer square
            {x: boardOffset + boardSize / 8, y: boardOffset + boardSize / 8},
            {x: boardOffset + boardSize / 2, y: boardOffset + boardSize / 8},
            {x: boardOffset + 7 * boardSize / 8, y: boardOffset + boardSize / 8},
            {x: boardOffset + 7 * boardSize / 8, y: boardOffset + boardSize / 2},
            {x: boardOffset + 7 * boardSize / 8, y: boardOffset + 7 * boardSize / 8},
            {x: boardOffset + boardSize / 2, y: boardOffset + 7 * boardSize / 8},
            {x: boardOffset + boardSize / 8, y: boardOffset + 7 * boardSize / 8},
            {x: boardOffset + boardSize / 8, y: boardOffset + boardSize / 2},
            // Middle square
            {x: boardOffset + boardSize / 4, y: boardOffset + boardSize / 4},
            {x: boardOffset + boardSize / 2, y: boardOffset + boardSize / 4},
            {x: boardOffset + 3 * boardSize / 4, y: boardOffset + boardSize / 4},
            {x: boardOffset + 3 * boardSize / 4, y: boardOffset + boardSize / 2},
            {x: boardOffset + 3 * boardSize / 4, y: boardOffset + 3 * boardSize / 4},
            {x: boardOffset + boardSize / 2, y: boardOffset + 3 * boardSize / 4},
            {x: boardOffset + boardSize / 4, y: boardOffset + 3 * boardSize / 4},
            {x: boardOffset + boardSize / 4, y: boardOffset + boardSize / 2},
            // Inner square
            {x: boardOffset + 3 * boardSize / 8, y: boardOffset + 3 * boardSize / 8},
            {x: boardOffset + boardSize / 2, y: boardOffset + 3 * boardSize / 8},
            {x: boardOffset + 5 * boardSize / 8, y: boardOffset + 3 * boardSize / 8},
            {x: boardOffset + 5 * boardSize / 8, y: boardOffset + boardSize / 2},
            {x: boardOffset + 5 * boardSize / 8, y: boardOffset + 5 * boardSize / 8},
            {x: boardOffset + boardSize / 2, y: boardOffset + 5 * boardSize / 8},
            {x: boardOffset + 3 * boardSize / 8, y: boardOffset + 5 * boardSize / 8},
            {x: boardOffset + 3 * boardSize / 8, y: boardOffset + boardSize / 2}
        ];
        
        // Adjacent positions (only for moving phase)
        const adjacentPositions = [
            [1, 7], [0, 2, 9], [1, 3], [2, 4, 11],
            [3, 5], [4, 6, 13], [5, 7], [0, 6, 15],
            [9, 15], [1, 8, 10, 17], [9, 11], [3, 10, 12, 19],
            [11, 13], [5, 12, 14, 21], [13, 15], [7, 8, 14, 23],
            [17, 23], [9, 16, 18], [17, 19], [11, 18, 20],
            [19, 21], [13, 20, 22], [21, 23], [15, 16, 22]
        ];
        
        // Mill combinations - ØªÙ…Ø§Ù… Ø®Ø·ÙˆØ· Ù…Ù…Ú©Ù† Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯Ù†
        const winningLines = [
            // Outer square lines
            [0, 1, 2], [2, 3, 4], [4, 5, 6], [6, 7, 0],
            // Middle square lines
            [8, 9, 10], [10, 11, 12], [12, 13, 14], [14, 15, 8],
            // Inner square lines
            [16, 17, 18], [18, 19, 20], [20, 21, 22], [22, 23, 16],
            // Diagonal lines across squares
            [1, 9, 17], [3, 11, 19], [5, 13, 21], [7, 15, 23],
            // Additional possible lines for more winning combinations
            [0, 8, 16], [2, 10, 18], [4, 12, 20], [6, 14, 22],
            [1, 10, 19], [3, 12, 21], [5, 14, 23], [7, 8, 16]
        ];
        
        // Game state - Ø³Ø§Ø¯Ù‡ Ø´Ø¯Ù‡
        let gameState = {
            board: new Array(24).fill(0), // 0 = empty, 1 = player1, 2 = player2
            phase: 1, // 1 = placing, 2 = moving (ÙØ§Ø² Ù¾Ø±ÙˆØ§Ø² Ø­Ø°Ù Ø´Ø¯)
            turn: 1, // 1 = player1, 2 = player2
            selectedPiece: -1,
            piecesToPlace: [PIECES_PER_PLAYER, PIECES_PER_PLAYER],
            piecesOnBoard: [0, 0],
            gameOver: false,
            winner: 0
        };
        
        // Colors
        const colors = {
            background: '#f5deb3',
            boardLines: '#654321',
            player1: '#dc143c',
            player2: '#1e90ff',
            highlight: '#32cd32',
            pointOutline: '#8b4513',
            winningLine: '#ffd700' // Ø±Ù†Ú¯ Ø·Ù„Ø§ÛŒÛŒ Ø¨Ø±Ø§ÛŒ Ø®Ø· Ø¨Ø±Ù†Ø¯Ù‡
        };
        
        // Initialize game
        function initGame() {
            updateGameInfo();
            drawBoard();
            
            // Add click event listener to canvas
            canvas.addEventListener('click', handleCanvasClick);
        }
        
        // Draw the game board
        function drawBoard() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw board lines
            ctx.strokeStyle = colors.boardLines;
            ctx.lineWidth = 3;
            
            // Outer square
            drawLine(0, 1);
            drawLine(1, 2);
            drawLine(2, 3);
            drawLine(3, 4);
            drawLine(4, 5);
            drawLine(5, 6);
            drawLine(6, 7);
            drawLine(7, 0);
            
            // Middle square
            drawLine(8, 9);
            drawLine(9, 10);
            drawLine(10, 11);
            drawLine(11, 12);
            drawLine(12, 13);
            drawLine(13, 14);
            drawLine(14, 15);
            drawLine(15, 8);
            
            // Inner square
            drawLine(16, 17);
            drawLine(17, 18);
            drawLine(18, 19);
            drawLine(19, 20);
            drawLine(20, 21);
            drawLine(21, 22);
            drawLine(22, 23);
            drawLine(23, 16);
            
            // Connecting lines between outer and middle squares
            drawLine(1, 9);
            drawLine(3, 11);
            drawLine(5, 13);
            drawLine(7, 15);
            
            // Connecting lines between middle and inner squares
            drawLine(9, 17);
            drawLine(11, 19);
            drawLine(13, 21);
            drawLine(15, 23);
            
            // Draw points
            for (let i = 0; i < boardPositions.length; i++) {
                const pos = boardPositions[i];
                
                // Draw point background
                ctx.fillStyle = colors.background;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, pointRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw point outline
                ctx.strokeStyle = colors.pointOutline;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, pointRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw piece if present
                if (gameState.board[i] === 1) {
                    drawPiece(pos.x, pos.y, colors.player1);
                } else if (gameState.board[i] === 2) {
                    drawPiece(pos.x, pos.y, colors.player2);
                }
            }
            
            // Highlight selected piece
            if (gameState.selectedPiece !== -1 && gameState.board[gameState.selectedPiece] === gameState.turn) {
                const pos = boardPositions[gameState.selectedPiece];
                ctx.strokeStyle = colors.highlight;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, pointRadius + 5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Draw winning line if game is over
            if (gameState.gameOver) {
                drawWinningLine();
            }
        }
        
        // Draw a line between two points
        function drawLine(index1, index2) {
            const pos1 = boardPositions[index1];
            const pos2 = boardPositions[index2];
            
            ctx.beginPath();
            ctx.moveTo(pos1.x, pos1.y);
            ctx.lineTo(pos2.x, pos2.y);
            ctx.stroke();
        }
        
        // Draw a game piece
        function drawPiece(x, y, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, pointRadius - 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, pointRadius - 3, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Draw the winning line
        function drawWinningLine() {
            const winningLine = findWinningLine();
            if (winningLine) {
                const pos1 = boardPositions[winningLine[0]];
                const pos2 = boardPositions[winningLine[2]];
                
                ctx.strokeStyle = colors.winningLine;
                ctx.lineWidth = 8;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(pos1.x, pos1.y);
                ctx.lineTo(pos2.x, pos2.y);
                ctx.stroke();
                
                // Draw golden circles on winning pieces
                for (const index of winningLine) {
                    const pos = boardPositions[index];
                    ctx.strokeStyle = colors.winningLine;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, pointRadius + 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }
        
        // Find which line caused the win
        function findWinningLine() {
            for (const line of winningLines) {
                const player = gameState.board[line[0]];
                if (player !== 0 && 
                    gameState.board[line[1]] === player && 
                    gameState.board[line[2]] === player) {
                    return line;
                }
            }
            return null;
        }
        
        // Handle canvas click
        function handleCanvasClick(event) {
            if (gameState.gameOver) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Find clicked position
            const clickedPos = findClickedPosition(x, y);
            
            if (clickedPos !== -1) {
                if (gameState.phase === 1) {
                    // Placing phase
                    if (placePiece(clickedPos)) {
                        // Check if we need to transition to phase 2
                        if (gameState.piecesToPlace[0] === 0 && gameState.piecesToPlace[1] === 0) {
                            gameState.phase = 2;
                            updatePhaseIndicator();
                        }
                    }
                } else if (gameState.phase === 2) {
                    // Moving phase
                    if (gameState.selectedPiece === -1) {
                        // Select a piece to move
                        if (gameState.board[clickedPos] === gameState.turn) {
                            gameState.selectedPiece = clickedPos;
                        }
                    } else {
                        // Try to move the selected piece
                        if (movePiece(gameState.selectedPiece, clickedPos)) {
                            gameState.selectedPiece = -1;
                        } else {
                            // If invalid move, try to select another piece
                            if (gameState.board[clickedPos] === gameState.turn) {
                                gameState.selectedPiece = clickedPos;
                            } else {
                                gameState.selectedPiece = -1;
                            }
                        }
                    }
                }
            } else {
                // Clicked outside the board, deselect piece
                gameState.selectedPiece = -1;
            }
            
            drawBoard();
            updateGameInfo();
        }
        
        // Find which position was clicked
        function findClickedPosition(x, y) {
            for (let i = 0; i < boardPositions.length; i++) {
                const pos = boardPositions[i];
                const distance = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                
                if (distance <= pointRadius) {
                    return i;
                }
            }
            return -1;
        }
        
        // Place a piece on the board
        function placePiece(position) {
            if (gameState.board[position] === 0) {
                gameState.board[position] = gameState.turn;
                gameState.piecesToPlace[gameState.turn - 1]--;
                gameState.piecesOnBoard[gameState.turn - 1]++;
                
                // Check for win
                if (checkWin(position)) {
                    gameState.gameOver = true;
                    gameState.winner = gameState.turn;
                    return true;
                } else {
                    changeTurn();
                    return true;
                }
            }
            return false;
        }
        
        // Move a piece on the board
        function movePiece(fromPos, toPos) {
            if (gameState.board[fromPos] === gameState.turn && gameState.board[toPos] === 0) {
                // Check if move is valid (only to adjacent positions in phase 2)
                if (!adjacentPositions[fromPos].includes(toPos)) {
                    return false;
                }
                
                // Perform the move
                gameState.board[fromPos] = 0;
                gameState.board[toPos] = gameState.turn;
                
                // Check for win
                if (checkWin(toPos)) {
                    gameState.gameOver = true;
                    gameState.winner = gameState.turn;
                    return true;
                } else {
                    changeTurn();
                    return true;
                }
            }
            return false;
        }
        
        // Check if placing or moving a piece causes a win
        function checkWin(position) {
            const player = gameState.board[position];
            if (player === 0) return false;
            
            // Check all winning lines that include this position
            for (const line of winningLines) {
                if (line.includes(position)) {
                    if (gameState.board[line[0]] === player && 
                        gameState.board[line[1]] === player && 
                        gameState.board[line[2]] === player) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Change turn to the other player
        function changeTurn() {
            gameState.turn = 3 - gameState.turn;
            
            // Update player turn indicator
            document.getElementById('player1Box').classList.toggle('current-turn', gameState.turn === 1);
            document.getElementById('player2Box').classList.toggle('current-turn', gameState.turn === 2);
        }
        
        // Update game information display
        function updateGameInfo() {
            // Update player pieces count
            document.getElementById('player1Pieces').textContent = gameState.piecesOnBoard[0];
            document.getElementById('player2Pieces').textContent = gameState.piecesOnBoard[1];
            document.getElementById('player1Remaining').textContent = gameState.piecesToPlace[0];
            document.getElementById('player2Remaining').textContent = gameState.piecesToPlace[1];
            
            // Update game message
            const messageElement = document.getElementById('gameMessage');
            
            if (gameState.gameOver) {
                messageElement.textContent = `ğŸ‰ ØªØ¨Ø±ÛŒÚ©! Ø¨Ø§Ø²ÛŒÚ©Ù† ${gameState.winner === 1 ? 'Ù‚Ø±Ù…Ø²' : 'Ø¢Ø¨ÛŒ'} Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯! ğŸ‰`;
                messageElement.className = 'message winning-message';
            } else if (gameState.phase === 1) {
                messageElement.textContent = `Ù†ÙˆØ¨Øª Ø¨Ø§Ø²ÛŒÚ©Ù† ${gameState.turn === 1 ? 'Ù‚Ø±Ù…Ø²' : 'Ø¢Ø¨ÛŒ'} (Ù‚Ø±Ø§Ø± Ø¯Ø§Ø¯Ù† Ø³Ù†Ú¯â€ŒÙ‡Ø§)`;
                messageElement.className = 'message';
            } else if (gameState.phase === 2) {
                messageElement.textContent = `Ù†ÙˆØ¨Øª Ø¨Ø§Ø²ÛŒÚ©Ù† ${gameState.turn === 1 ? 'Ù‚Ø±Ù…Ø²' : 'Ø¢Ø¨ÛŒ'} (Ø­Ø±Ú©Øª Ø³Ù†Ú¯â€ŒÙ‡Ø§)`;
                messageElement.className = 'message';
            }
        }
        
        // Update phase indicator
        function updatePhaseIndicator() {
            document.getElementById('phase1').classList.toggle('active', gameState.phase === 1);
            document.getElementById('phase2').classList.toggle('active', gameState.phase === 2);
        }
        
        // Restart the game
        function restartGame() {
            gameState = {
                board: new Array(24).fill(0),
                phase: 1,
                turn: 1,
                selectedPiece: -1,
                piecesToPlace: [PIECES_PER_PLAYER, PIECES_PER_PLAYER],
                piecesOnBoard: [0, 0],
                gameOver: false,
                winner: 0
            };
            
            updatePhaseIndicator();
            updateGameInfo();
            drawBoard();
            
            // Reset player turn indicators
            document.getElementById('player1Box').classList.add('current-turn');
            document.getElementById('player2Box').classList.remove('current-turn');
        }
        
        // Toggle rules panel
        function toggleRules() {
            document.getElementById('rulesPanel').classList.toggle('active');
        }
        
        // Start the game when page loads
        window.onload = initGame;
    </script>
</body>
</html>
